
AT&T記法とIntel記法の二つがある。
AT&T構文とIntel構文での違いは以下の通りである。
・at&t構文ではレジスタの前に%がつく
・読み込み元オペランドと格納先オペランドの順序が逆
・at&t構文では即値オペランドの前に$がつく
・アドレッシングはat&tはレジスタを()で囲み、intelでは[]で囲む
・at&t記法ではオペランドのサイズによって適切なサフィックスを付加する必要がある(mov —> movl)

=== 1 === 

レジスタ : データを操作するための変数(データの格納場所)。
8個の汎用ジレスタ(GPR)、6個のセグメントレジスタ、1個のフラグレジスタ、1個の命令ポインタを持つ。

汎用レジスタ(GPR)
rax 	:	アキュムレータレジスタ　計算、返り値の格納
rbx 	: 	ベースレジスタ　
rcx  	:	カウンタレジスタ　ループ命令など
rdx 	: 	データレジスタ　算術演算操作やI/O操作など
rsp 	: 	スタックポインターレジスタ　スタックのトップを指し示すポインタ
rbp 	: 	スタックベースポインタレジスタ　スタックのベースを指し示す
rsi 	:　	ソースレジスタ ストリーム操作でのソースへのポインタとして使用
rdi 	:　	ディスティネーションレジスタ　ストリーム操作でのディスティネーションのポインタとして使用
rip	:	次に実行される命令のアドレスを保持する。


以下、at&t記法での記述とする。

mov : 
第1オペランド(読み込み元)を第2オペランド(格納先)にコピーする。
第1オペランドには即値、汎用レジスタ、セグメントレジスタ、メモリアドレスが使用できる。
第2オペランドには、汎用レジスタ、セグメントレジスタ、メモリアドレスが使用できる。

add : 
加算命令。２つのオペランドを引数に取り、第2オペランド(格納先)と第1オペランド(読み込み元)の和を第2オペランドに格納する。
格納先にはレジスタとメモリ、読み込み元には即値、レジスタ、メモリのアドレスを使用できる。(両方に同時にメモリアドレスを指定する事はできない)

sub : 
減算命令。２つのオペランドを引数に取り、第2オペランド(格納先)と第1オペランド(読み込み元)の差を第2オペランドに格納する。
格納先にはレジスタとメモリ、読み込み元には即値、レジスタ、メモリのアドレスを使用できる。(両方に同時にメモリアドレスを指定する事はできない)

call :
戻り先のアドレスをスタックにPUSHし、オペランドで指定されるプロシージャに分岐する(関数呼び出し)。
オペランドはコール先の最初の命令が格納されているアドレスを指定する。
オペランドは即値、汎用レジスタ、メモリアドレスを使用できる。

ret : 
return。プログラムの制御をスタックのトップにあるリターンアドレスに移す。
オプションの読み込み元オペランドはリターンアドレスがPOPされた後にリリースされるスタックのバイト数を指定する。

jmp:
リターン先をPUSHしないで分岐する。オペランドには分岐先の命令があるアドレスを指定する。
オペランドには即値、汎用レジスタ、メモリアドレスが使用可能。

1.1 raxレジスタへ即値0x12345678を入れる : 
mov $0x12345678,%rax 

1.2 rbxレジスタにはメモリアドレスが入っている。raxにrbxが指すアドレスの値を入れる。
mov %rbx,%rax

1.3 rbxレジスタにメモリアドレスが入っている。rbxが指すアドレスにraxの値を入れる。
mov %rax,(%rbx)

1.4 rbpレジスタにメモリアドレスが入っている。raxに(rbp - 4)が指しているアドレスの値を入れる。
mov -0x4(%rbp),%rax

1.5
call:
ripレジスタには次に実行される命令のアドレスが入る。call命令が行われると、その時にripが持つメモリアドレスの値(call命令の次の命令)をスタックにpushする。
その後、ripにcall命令で指定されたメモリアドレスを設定することで、次に実行される命令が呼び出し先の命令になる。
ret :
rspの指すメモリアドレスから値を読み出し、ripに設定する(pop命令)。
retが呼び出された際にrspが指しているアドレスに格納されている値は、call命令の呼び出し時にスタックに格納された、呼び出し元のcall命令の次の命令のメモリアドレスになっている。

jmp:
ripレジスタに、jmp命令で指定されたメモリアドレスの値を代入する。


=== 2 === 
mac,端末(terminal)にて実験を行った。
objdumpコマンドを用いることができないため、gobjdumpコマンドにて確認した。

func0~func7までの関数はそれぞれそのアドレスと名前にアンダーバーをつけた名前でラベルづけされていた。
(例:0000000100000cfe <_func0>)
また、どの関数内でも共通している処理として、
push   %rbp
mov    %rsp,%rbp
が最初に行われる。この処理によって、関数呼び出し前にスタックに格納されているデータを保持している。

2.1
main関数のあるアドレス : 0000000100000d8c
逆アセンブルにより得られたプログラムより、main関数が<_main>の形でラベルづけされていた。

2.2
call命令によって、ラベルづけされた関数を呼び出している。(サフィックスはq)
アドレスの直接指定かと思ったが、callq 100000cfe <_func0>のようにオベランドが指定されていることから、ラベルによる呼び出しであると考えられる。

2.3
返り値はeaxレジスタを通して返される。呼び出し元で返り値を用いる場合には、予め確保しておいたスタック領域にeaxの値をコピーする。

2.4
引数はediレジスタを通して関数へ渡される。call命令の前にmov命令を用いてediレジスタに値をコピーする。呼ばれた側では、ediレジスタの値をスタックに格納して扱う。
引数が増えるとついでesi,edx,ecx,r8d,r9dレジスタが用いられていたが、それよりもさらに多い数の引数を取る場合には、push命令によって、後に入力された引数から順にスタックへpushされていた。
その場合に呼ばれた側で引数の値を用いる際には、呼ばれた側で変更されたrbpレジスタのメモリアドレスに、用いる引数に準じた値を足したメモリアドレスの値を読み取ることで、引数の値を用いていた。


2.5
ローカル変数の確保は、rspレジスタの指すスタックのトップのメモリアドレスの値を、用いるローカル変数の合計バイト数に準じた値で引くことで、変数として扱うメモリ領域を確保する。
自身の環境で得られたアセンブラでは、n0に該当するメモリアドレスが-0x4(%rbp),n3に該当するメモリアドレスが-0x8(%rbp)のようになっていた。
また、プログラムを変更し、func0を呼び出す前にn7に30を代入する処理を行ったところ、n7として扱われるメモリアドレスが-0x4(%rbp)となった。
このことから、宣言された順番ではなく、実際に使用された順番にメモリアドレスが割り当てられるような処理になっていることがわかる。

=== 3 === 
呼びだされた関数内で呼び出し元のローカル変数の値にアクセスができるかについて検証した。
宣言された変数n0,n3,n4,n6,n7について、それぞれ次の値をあらかじめ代入しておく。
また、このプログラムでは、変数として扱われるメモリアドレスは次のようになっていた。

n0 = 0 : -4(%rbp) —> 28(%rsp)
n3 = 10: -8(%rbp) —> 24(%rsp)
n4 = 20: -12(%rbp) —> 20(%rsp)
n6 = 30: -16(%rbp) —> 16(%rsp)
n7 = 40: -20(%rbp)—> 12(%rsp)

これを踏まえた上で、func0の処理を次のようなものにしてみる。
_func0:
	pushq	%rbp
	movq	%rsp, %rbp
	movl	0x20(%rsp), %eax
	popq	%rbp
	ret

それぞれに値を代入したのち、func0を実行した場合にこの関数から得られた値(eaxレジスタの値)は30であった。
つまり、_func0内で0x20(%rsp)を指定した場合に読み取られた値はn6の値となった。

rspレジスタの値は,スタックのトップを常に指すようになっている。
main関数内で変数のための領域を確保した際に,0x20(32byte)の値がrspから引かれており、またpushq,callqによってrspは0x10(16byte)移動する。
したがって、func_0内でのrspレジスタの指すメモリアドレスはmain関数内が始まった際のrspの値を起点とすると、0x30(48byte)オフセットがずれていることになる。
func_0内でのrspの値に0x20を足したメモリアドレスの場所は(0x20 - 0x10)となり、main関数内での0x10(%rsp)、
つまり16(%rsp)に該当することから、main関数内でのローカル変数であるn6に当たる値を読み取ることができる。